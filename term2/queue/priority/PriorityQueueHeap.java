package term2.queue.priority;
/**
 * Приоритетная очередь на базе пирамиды(кучи)
 * Пирамидой называется двоичное дерево, обладающее следующими характеристиками:
 * 1) Полнота. Все уровни дерева содержат все возможные узлы(хотя последний уровень 
 * может быть заполнен лишь частично)
 * 2) Для каждого узла в пирамиде выполняется основное условие, гласящее, что ключ 
 * каждого узла меньше(либо равен) ключей его потомков.
 * 
 * Пирамида обычно реализуется на базе массива. Из того факта, что пирамида является 
 * полным двоичным деревом, следует, что в массиве, который используется для ее представления, 
 * нет "дыр". Заполнены все ячейки от 0 до size-1.
 * 
 * Мы будем писать пирамиду, где на вершине находится минимальный элемент. 
 * Но можно реализовать и пирамиду, где на вершине максимальный элемент, и каждый узел больше(или равен) 
 * своих потоков.
 * 
 * По сравнению с деревом двоичного поиска, в котором ключ левого потомка каждого узла меньше ключа правого потомка, 
 * пирамида является слабо упорядоченной.
 */

public class PriorityQueueHeap<T> implements PriorityQueue<T> {
	
	private Object[] heap = new Object[4];
	private int size;

	/**
	 * Сначала проверяем, осталось ли в массиве свободное место. Новый элемент
	 * всегда вставляется в первую свободную ячейку массива, справа от
	 * последнего узла на нижнем уровне пирамиды. После этого этот элемент
	 * перемещается в правильную позицию. 
	 * 
	 * Алгоритм смещения вверх проще алгоритма смещения вниз, потому что он не требует сравнения двух
	 * потомков. Узел имеет только одного родителя, так что вставляемый узел
	 * просто меняется местами с родителем, пока не дойдет большего предка или
	 * не станет корневым узлом.
	 * Можно сократить количество перестановок, если действовать способом аналогичным тому, 
	 * который применяется в сортировке вставками: запоминаем значение узла, смещаем его родителей вниз 
	 * посредством копирования на каждом шаге значения родителя в текущую ячейку. А после того как дошли 
	 * до нужной позиции узла, записываем его значение в ячейку один раз.
	 */
	@SuppressWarnings("unchecked")
	@Override
	public void offer(T e) {
		if (e == null) {
			throw new NullPointerException();
		}
		ensureCapacity(size + 1);		
		if (size == 0) {
			heap[0] = e;
		} else {
			upHeapify(size, e);
		}
		size++;
	}

	private void upHeapify(int k, T x) {
		Comparable<? super T> key = (Comparable<? super T>) x;
		while (k > 0) {
			int parent = (k - 1) >>> 1;
			Object e = heap[parent];
			if (key.compareTo((T) e) >= 0) {
				break;
			}
			heap[k] = e;
			k = parent;
		}
		heap[k] = key;
	}
		 
	
	private void ensureCapacity(int size) {
		if (size <= heap.length) {
			return;
		}
		/*
		 * создаем новый массив размера в 2 раза больше, чем количество
		 * элементов, которое мы хотим там разместить
		 */
		Object[] newElements = new Object[2 * size];
		// копируем в него элементы из старого массива
		for (int i = 0; i < heap.length; i++) {
			newElements[i] = heap[i];
		}
		// присваеваем новый массив полю elements
		heap = newElements;
	}

	/**
	 * Минимальный узел всегда является корневым и хранится в нулевой ячейке массива.
	 * Проблема в том, что после удаления корень необходимо заполнить.
	 * Вместо сдвига всех элементов на одну позицию вперед используется более быстрое решение:
	 * 1) Удалить корневой узел
	 * 2) Переместить последний узел на место корневого
	 * 3) Смещать его вниз до тех пор, пока он не окажется ниже меньшего и выше большего узла.
	 */
	@SuppressWarnings("unchecked")
	@Override
	public T poll() {
		if (size == 0) {
			return null;
		}
		--size;
		//запоминаем значение корневого узла
		T result = (T)heap[0];
		//перемещаем последний узел на место корневого
		heap[0] =  heap[size];
		//удаляем лишнюю ссылку, которая осталась от последнего элемента
		heap[size] = null;
		if (size != 0) {
			//смещаем новую вершину вниз до позиции удовлетворяющей свойству пирамиды
			downHeapify(0);
		}
		return result;
	}

	/**
	 * Смещает узел с индексом index вниз до тех пор, пока он не окажется ниже меньшего и выше большего узла.
	 * @param index индекс смещаемого вниз узла
	 */
	@SuppressWarnings("unchecked")
	private void downHeapify(int index) {
		Comparable<? super T> key = (Comparable<? super T>) heap[index];
		int half = size / 2; 
		//пока у узла имеется хотя бы один потомок
		while (index < half) {
			int leftChild = 2*index + 1; 
			int rightChild = leftChild + 1;
			//определяем индекс большего потомка
			int smallestChild = leftChild;
			//если правый потомок существует и он больше левого
			if (rightChild < size && ((Comparable<? super T>) heap[leftChild]).compareTo((T) heap[rightChild]) > 0) {
				smallestChild = rightChild;				
			}
			//если текущей узел меньше обоих потомков, то смещение вниз закончено
			if (key.compareTo((T) heap[smallestChild]) <= 0) {
				break;
			}
			//в противном случае меньший потомок перемещается на место текущего узла
			heap[index] = heap[smallestChild];
			//перемещаем индекс на место меньшего потомка и продолжем смещение вниз тем же алготитмом
			index = smallestChild;
		}
		//вставляем узел в нужную позицию
		heap[index] = key;
	}

	@SuppressWarnings("unchecked")
	@Override
	public T peek() {
		return (T) heap[0];
	}

	@Override
	public int size() {
		return size;
	}

	@Override
	public boolean isEmpty() {
		return size == 0;
	}

	@Override
	public boolean isFull() {
		return false;
	}

	@Override
	public void printQueue() {
		for (int i = 0; i < size; i++) {
			System.out.print(heap[i] + " ");
		}
		System.out.println();
	}

}
