package ru.kpfu.itis.oop.list;
/**
 * Список на основе массива
 * 
 * Ключевое слово extends, а затем имя родительского класса указывает на то, что данный класс расширяет другой класс, 
 * наследуется от другого класса. В данном случае класс ArrayList расширяет класс AbstractList.
 * Класс AbstractList - родительский класс класса ArrayList.
 * Класс ArrayList производный от класса AbstractList.
 * 
 * Класс ArrayList наследует все public и protected поля и методы родительского класса.
 * Обратите внимание, что внутри класса мы обращаемся к полю size, хотя оно здесь не объявлено.
 * Поле size унаследовалось от родительского класса.
 * 
 * Благодаря наследованию объект типа ArrayList также является объектом типа AbstractList.
 * Следующая запись абсолютно корректна AbstractList list = new ArrayList();
 *
 */
public class ArrayList extends AbstractList {
	/**
	 * Массив, в котором хранятся значения элементов списка
	 * 
	 * elements - это поле класса ArrayList.
	 * 
	 * Модификатор доступа у данного поля - private. Это означает, 
	 * что доступ к данному полю есть только внутри данного класса.
	 * Таким образом мы скрываем внутреннюю реализацию класса.
	 * 
	 * Для чего мы это делаем:
	 * 1)Пользователи класса видят только важные для них методы, 
	 * что упрощает понимание и использование кода
	 * 2)Мы получаем возможность изменять структуру класса, не затрагивая при этом 
	 * пользователей класса. Например, если мы захотим переименовать поле elements, 
	 * мы легко это сможем сделать,  поскольку мы можем быть уверны, 
	 * что доступ к полю закрыт вне данного класса. 
	 * 
	 * Контроль над доступом называют сокрытием реализации. 
	 * Помещение данных и методов в классы в комбинации с сокрытием реализации называют инкапсуляцией.
	 */
	private Object[] elements;

	/**
	 * Конструктор без параметров или конструктор по умолчанию.
	 * По умолчанию создаем массив размера 5.
	 */
	public ArrayList() {
		/**
		 *  Ключевое слово this представляет собой ссылку на объект,
		 *  для которого был вызван метод или конструктор.
		 *  Может использоваться только внутри нестатических методов 
		 * 
		 * В данном случае this используется для вызова коструктора с параметром текущего класса
		 * см. его определение ниже
		 */
		this(5);
	}
	
	/**
	 * Конструктор с параметром
	 * @param size начальный размер массива elements 
	 */
	public ArrayList(int size) {
		/* Вызов родительского конструктора
		 * Можно не писать, конструктор без параметров родительского класса вызовется автоматически.
		 * Есть необходимость использовать явно только конструктор родительского класса с параметрами. 
		 * */
		super();
		//создаем массив заданного размера		
		elements = new Object[size];
	}
	
	/**
	 * Метод добавления элемента в конец списка
	 */
	public void add(Object o) {		
		ensureCapacity(size + 1);
		elements[size++] = o;
		
	}

	/**
	 * Метод получения значения элемента по индексу
	 */
	public Object get(int i) {
		if (i >= size) {
			return null;
		}
		return elements[i];
	}

	/**
	 * Метод удаления элемента по индексу
	 */
	public Object remove(int i) {
		if (i >= size) {
			return null;
		}
		Object oldValue = elements[i];
		//сдвигаем элемены на 1 позицию вперед
		for (int j = i; j < size; j++) {
			elements[j] = elements[j + 1];
		}
		//обнуляем последний элемент и уменьшаем размер списка
		elements[--size] = null;
		return oldValue;
	}
	
	/**
	 * Метод проверяет поместится ли в массив elements size элементов
	 * При необходимости увеличивает массив elements
	 * @param size количество элементов, которое должно входить в массив elements
	 * 
	 * Модификатор доступа private указывает на то, что данный метод доступен только в текущем классе.
	 * Это вспомогательный метод, мы не хотим, чтобы пользователям он был виден.
	 */
	private void ensureCapacity(int size) {
		if (size <= elements.length) {
			return;
		}
		/* создаем новый массив размера в 2 раза больше, 
		 * чем количество элементов, которое мы хотим там разместить
		 */
		Object[] newElements = new Object[2 * size];
		//копируем в него элементы из старого массива
		for (int i = 0; i < elements.length; i++) {
			newElements[i] = elements[i];
		}
		//присваеваем новый массив полю elements
		elements = newElements;
	}
	
	/**
	 * Логики нет, просто пример переопределения метода родительского класса.
	 * 
	 *  Если вы переопределяете какой-то из методов родительского класса, то имейте в виду, что в Java при наследовании запрещается уменьшать уровень доступа, 
	 *  поэтому при наследовании protected методы и поля в классе потомке должны иметь доступ protected или public,
	 *  в public методы и поля родительского класса должны иметь public доступ в классе потомке.  
	 *  
	 *  Модификаторы доступа от меньшего к большему:
	 *  private - доступ на уровне класса
	 *  по умолчанию - доступ в текущем пакете
	 *  protected - доступ в текущем пакете и в классах наследниках
	 *  public - доступен везде
	 */
	public boolean isEmpty() {
		return true;
	}
}
